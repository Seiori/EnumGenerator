using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace EnumGenerator;

public readonly record struct EnumMemberInfo(
    string Name,
    string? DisplayName,
    string? SerializedName
);

public readonly record struct EnumToGenerate(
    string Name,
    string Namespace,
    string UnderlyingType,
    ImmutableArray<EnumMemberInfo> Members
);

[Generator]
public class MyEnumGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var enumToGenerate = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is EnumDeclarationSyntax,
                transform: static (ctx, _) => GetEnumToGenerate(ctx)
            )
            .Where(static m => m is not null)
            .Select(static (m, _) => m!.Value);

        context.RegisterSourceOutput(enumToGenerate, static (spc, source) => Execute(spc, source));
    }

    private static EnumToGenerate? GetEnumToGenerate(GeneratorSyntaxContext context)
    {
        var enumDeclaration = (EnumDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(enumDeclaration);

        if (symbol is not INamedTypeSymbol enumSymbol) return null;

        var members = ImmutableArray.CreateBuilder<EnumMemberInfo>();
        foreach (var member in enumSymbol.GetMembers())
        {
            if (member is IFieldSymbol { IsConst: true } fieldSymbol)
            {
                string? displayName = null;
                string? serializedName = null;

                foreach (var attribute in fieldSymbol.GetAttributes())
                {
                    var attrClass = attribute.AttributeClass?.ToDisplayString();

                    switch (attrClass)
                    {
                        case "System.ComponentModel.DataAnnotations.DisplayAttribute":
                        {
                            var nameArg = attribute.NamedArguments.FirstOrDefault(x => x.Key == "Name");
                            if (nameArg.Key is not null)
                            {
                                displayName = nameArg.Value.Value?.ToString();
                            }

                            break;
                        }
                        case "System.ComponentModel.DescriptionAttribute":
                        {
                            if (attribute.ConstructorArguments.Length > 0 && displayName is null)
                            {
                                displayName = attribute.ConstructorArguments[0].Value?.ToString();
                            }

                            break;
                        }
                        case "System.Runtime.Serialization.EnumMemberAttribute":
                        {
                            var valueArg = attribute.NamedArguments.FirstOrDefault(x => x.Key == "Value");
                            if (valueArg.Key is not null)
                            {
                                serializedName = valueArg.Value.Value?.ToString();
                            }

                            break;
                        }
                        case "System.Text.Json.Serialization.JsonPropertyNameAttribute":
                        {
                            if (attribute.ConstructorArguments.Length > 0)
                            {
                                serializedName = attribute.ConstructorArguments[0].Value?.ToString();
                            }

                            break;
                        }
                    }
                }

                members.Add(new EnumMemberInfo(fieldSymbol.Name, displayName, serializedName));
            }
        }

        var ns = enumSymbol.ContainingNamespace.IsGlobalNamespace
            ? string.Empty
            : enumSymbol.ContainingNamespace.ToString();

        var underlyingType = enumSymbol.EnumUnderlyingType?.ToDisplayString() ?? "int";

        return new EnumToGenerate(enumSymbol.Name, ns, underlyingType, members.ToImmutable());
    }

    private static void Execute(SourceProductionContext context, EnumToGenerate enumToGen)
    {
        var sb = new StringBuilder();
        var nsDeclaration = string.IsNullOrEmpty(enumToGen.Namespace) ? string.Empty : $"namespace {enumToGen.Namespace};";

        sb.Append($$"""
            // <auto-generated />
            #nullable enable
            using System;
            using System.Runtime.CompilerServices;

            {{nsDeclaration}}

            public static class {{enumToGen.Name}}Extensions
            {
                public const int Length = {{enumToGen.Members.Length}};

                private static readonly {{enumToGen.Name}}[] _values = new[]
                {
            """);

        foreach (var member in enumToGen.Members)
        {
            sb.Append($"        {enumToGen.Name}.{member.Name},");
        }

        sb.Append($$"""

                };

                private static readonly string[] _names = new[]
                {
            """);

        foreach (var member in enumToGen.Members)
        {
            sb.Append($"        \"{member.Name}\",");
        }

        sb.Append($$"""

                };

                public static ReadOnlySpan<{{enumToGen.Name}}> GetValues() => _values;

                public static ReadOnlySpan<string> GetNames() => _names;

                public static bool IsDefined({{enumToGen.Name}} value)
                {
                    return value switch
                    {
            """);

        foreach (var member in enumToGen.Members)
        {
            sb.AppendLine($"            {enumToGen.Name}.{member.Name} => true,");
        }

        sb.Append($$"""
                        _ => false
                    };
                }

                public static string GetString(this {{enumToGen.Name}} value)
                {
                    return value switch
                    {
            """);

        foreach (var member in enumToGen.Members)
        {
            sb.AppendLine();
            sb.Append($"            {enumToGen.Name}.{member.Name} => \"{member.Name}\",");
        }

        sb.Append($$"""

                        _ => value.ToString()
                    };
                }

                public static string GetEnumMemberValue(this {{enumToGen.Name}} value)
                {
                    return value switch
                    {
            """);

        foreach (var member in enumToGen.Members)
        {
            var serialized = member.SerializedName ?? member.Name;
            sb.AppendLine();
            sb.Append($"            {enumToGen.Name}.{member.Name} => \"{serialized}\",");
        }

        sb.Append($$"""

                        _ => value.ToString()
                    };
                }

                public static string GetDisplayValue(this {{enumToGen.Name}} value)
                {
                     return value switch
                     {
            """);

        foreach (var member in enumToGen.Members)
        {
            var display = member.DisplayName ?? member.Name;
            sb.AppendLine();
            sb.Append($"            {enumToGen.Name}.{member.Name} => \"{display}\",");
        }

        sb.Append($$"""

                        _ => value.ToString()
                    };
                }

                public static string GetStringUpperCase(this {{enumToGen.Name}} value)
                {
                    return value switch
                    {
            """);

        foreach (var member in enumToGen.Members)
        {
            sb.AppendLine();
            sb.Append($"            {enumToGen.Name}.{member.Name} => \"{member.Name.ToUpperInvariant()}\",");
        }

        sb.Append($$"""

                        _ => value.ToString().ToUpperInvariant()
                    };
                }

                public static string GetStringLowerCase(this {{enumToGen.Name}} value)
                {
                    return value switch
                    {
            """);

        foreach (var member in enumToGen.Members)
        {
            sb.AppendLine();
            sb.Append($"            {enumToGen.Name}.{member.Name} => \"{member.Name.ToLowerInvariant()}\",");
        }

        sb.Append($$"""

                        _ => value.ToString().ToLowerInvariant()
                    };
                }

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                public static {{enumToGen.UnderlyingType}} GetUnderlyingValue(this {{enumToGen.Name}} value)
                {
                    return ({{enumToGen.UnderlyingType}})value;
                }

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                public static bool TryParse(string? str, out {{enumToGen.Name}} result)
                {
                    if (str is null)
                    {
                        result = default;
                        return false;
                    }
                    return TryParse(str.AsSpan(), out result);
                }

                public static bool TryParse(ReadOnlySpan<char> span, out {{enumToGen.Name}} result)
                {
                    switch (span.Length)
                    {
            """);

        var parseTokens = new List<(string Token, string MemberName)>();
        
        foreach(var member in enumToGen.Members)
        {
            parseTokens.Add(!string.IsNullOrEmpty(member.SerializedName)
                ? (member.SerializedName!, member.Name)
                : (member.Name, member.Name));
        }

        var groupedByLength = parseTokens
            .GroupBy(x => x.Token.Length)
            .OrderBy(x => x.Key);

        foreach (var group in groupedByLength)
        {
            sb.AppendLine();
            sb.AppendLine($"            case {group.Key}:");
            foreach (var (token, memberName) in group)
            {
                sb.AppendLine($"                if (span.Equals(\"{token}\", StringComparison.OrdinalIgnoreCase))");
                sb.AppendLine("                {");
                sb.AppendLine($"                    result = {enumToGen.Name}.{memberName};");
                sb.AppendLine("                    return true;");
                sb.AppendLine("                }");
            }
            sb.Append("                break;");
        }

        sb.Append($$"""

                    }
                    
                    result = default;
                    return false;
                }

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                public static {{enumToGen.Name}} Parse(ReadOnlySpan<char> span)
                {
                    if (TryParse(span, out var result))
                    {
                        return result;
                    }
                    throw new ArgumentException($"Requested value '{span.ToString()}' was not found in enum '{{enumToGen.Name}}'.");
                }
            }
            """);

        context.AddSource($"{enumToGen.Name}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}